{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Documents/BilliardOS/app/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\r\n\r\nconst prismaClientSingleton = () => {\r\n    return new PrismaClient();\r\n};\r\n\r\ntype PrismaClientSingleton = ReturnType<typeof prismaClientSingleton>;\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n    prisma: PrismaClientSingleton | undefined;\r\n};\r\n\r\nexport const prisma = globalForPrisma.prisma ?? prismaClientSingleton();\r\n\r\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,wBAAwB;IAC1B,OAAO,IAAI,6IAAY;AAC3B;AAIA,MAAM,kBAAkB;AAIjB,MAAM,SAAS,gBAAgB,MAAM,IAAI;AAEhD,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Lenovo/Documents/BilliardOS/app/src/app/api/transactions/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\nimport { z } from \"zod\";\r\n\r\nconst itemSchema = z.object({\r\n    id: z.string().optional(),\r\n    name: z.string(),\r\n    price: z.number(),\r\n    qty: z.number(),\r\n    type: z.enum(['PRODUCT', 'TABLE_BILL', 'OTHER']),\r\n});\r\n\r\nconst transactionSchema = z.object({\r\n    memberId: z.number().optional().nullable(),\r\n    customerName: z.string().optional().nullable(),\r\n    sessionId: z.number().optional().nullable(),\r\n    paymentMethod: z.enum(['CASH', 'QRIS', 'DEBIT', 'CREDIT']),\r\n    items: z.array(itemSchema),\r\n    pointsRedeemed: z.number().optional(),\r\n});\r\n\r\nexport async function POST(request: Request) {\r\n    try {\r\n        const body = await request.json();\r\n        const { memberId, customerName, sessionId, paymentMethod, items, pointsRedeemed = 0 } = transactionSchema.parse(body);\r\n\r\n        // Calculate Totals\r\n        let subtotal = 0;\r\n        items.forEach(item => {\r\n            subtotal += item.price * item.qty;\r\n        });\r\n\r\n        // Calculate Discount (1 Point = Rp 1.000)\r\n        let discountAmount = 0;\r\n        if (pointsRedeemed > 0 && memberId) {\r\n            const member = await prisma.member.findUnique({ where: { id: memberId } });\r\n            if (!member || member.pointsBalance < pointsRedeemed) {\r\n                return NextResponse.json({ error: \"Insufficient points\" }, { status: 400 });\r\n            }\r\n            discountAmount = pointsRedeemed * 1000;\r\n        }\r\n\r\n        const taxRate = 0.11;\r\n        const taxableAmount = Math.max(0, subtotal - discountAmount);\r\n        const taxAmount = Math.round(taxableAmount * taxRate);\r\n        const totalAmount = taxableAmount + taxAmount;\r\n\r\n        // Generate Invoice No\r\n        const invoiceNo = `INV-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\r\n\r\n        // Use raw SQL - need explicit CAST for PostgreSQL enums\r\n        const orderResult = await prisma.$queryRawUnsafe<{ id: number }[]>(`\r\n            INSERT INTO orders (\r\n                invoice_no, session_id, member_id, customer_name, subtotal, \r\n                discount_amount, points_redeemed, tax_amount, \r\n                total_amount, payment_method, payment_status, created_at\r\n            ) VALUES (\r\n                $1, $2, $3, $4, $5,\r\n                $6, $7, $8,\r\n                $9, $10::\"PaymentMethod\", 'PAID'::\"PaymentStatus\", NOW()\r\n            )\r\n            RETURNING id\r\n        `, invoiceNo, sessionId || null, memberId || null, customerName || null, subtotal,\r\n            discountAmount, pointsRedeemed, taxAmount, totalAmount, paymentMethod\r\n        );\r\n\r\n        const orderId = orderResult[0]?.id;\r\n        if (!orderId) throw new Error(\"Failed to create order\");\r\n\r\n        // Insert order items\r\n        for (const item of items) {\r\n            await prisma.$executeRaw`\r\n                INSERT INTO order_items (\r\n                    order_id, product_id, item_name, quantity, unit_price, total_price\r\n                ) VALUES (\r\n                    ${orderId}, ${item.type === 'PRODUCT' ? item.id : null},\r\n                    ${item.name}, ${item.qty}, ${item.price}, ${item.price * item.qty}\r\n                )\r\n            `;\r\n\r\n            // Reduce stock for products\r\n            if (item.type === 'PRODUCT' && item.id) {\r\n                await prisma.$executeRaw`\r\n                    UPDATE products SET stock_qty = stock_qty - ${item.qty} WHERE id = ${item.id}\r\n                `;\r\n            }\r\n        }\r\n\r\n        // Handle Points (if member)\r\n        if (memberId) {\r\n            if (pointsRedeemed > 0) {\r\n                await prisma.$executeRaw`\r\n                    UPDATE members SET points_balance = points_balance - ${pointsRedeemed} WHERE id = ${memberId}\r\n                `;\r\n                await prisma.$executeRaw`\r\n                    INSERT INTO point_transactions (member_id, type, amount, description, created_at)\r\n                    VALUES (${memberId}, 'REDEEM', ${-pointsRedeemed}, ${`Redeemed for ${invoiceNo}`}, NOW())\r\n                `;\r\n            }\r\n\r\n            const pointsEarned = Math.floor(totalAmount / 10000);\r\n            if (pointsEarned > 0) {\r\n                await prisma.$executeRaw`\r\n                    UPDATE members SET points_balance = points_balance + ${pointsEarned} WHERE id = ${memberId}\r\n                `;\r\n                await prisma.$executeRaw`\r\n                    INSERT INTO point_transactions (member_id, type, amount, description, created_at)\r\n                    VALUES (${memberId}, 'EARN', ${pointsEarned}, ${`Transaction ${invoiceNo}`}, NOW())\r\n                `;\r\n            }\r\n        }\r\n\r\n        return NextResponse.json({ success: true, order: { id: orderId, invoiceNo } });\r\n    } catch (error) {\r\n        console.error(\"Transaction Error:\", error);\r\n        if (error instanceof z.ZodError) {\r\n            return NextResponse.json({\r\n                error: \"Validation Error\",\r\n                details: error.issues\r\n            }, { status: 400 });\r\n        }\r\n        // Return actual error message for debugging\r\n        const message = error instanceof Error ? error.message : \"Internal Error\";\r\n        return NextResponse.json({ error: message }, { status: 500 });\r\n    }\r\n}\r\n\r\nexport async function GET(request: Request) {\r\n    try {\r\n        const { searchParams } = new URL(request.url);\r\n        const page = Number(searchParams.get('page')) || 1;\r\n        const limit = Number(searchParams.get('limit')) || 10;\r\n        const skip = (page - 1) * limit;\r\n        const startDate = searchParams.get('startDate');\r\n        const endDate = searchParams.get('endDate');\r\n        const paymentMethod = searchParams.get('paymentMethod');\r\n        const search = searchParams.get('search');\r\n\r\n        const where: any = {};\r\n\r\n        // Date Filter\r\n        if (startDate || endDate) {\r\n            where.createdAt = {};\r\n            if (startDate) where.createdAt.gte = new Date(startDate);\r\n            if (endDate) {\r\n                const end = new Date(endDate);\r\n                end.setHours(23, 59, 59, 999); // End of day\r\n                where.createdAt.lte = end;\r\n            }\r\n        }\r\n\r\n        // Payment Method Filter\r\n        if (paymentMethod && paymentMethod !== 'ALL') {\r\n            // Use type casting or ensure your input is valid PaymentMethod\r\n            where.paymentMethod = paymentMethod as any;\r\n        }\r\n\r\n        // Search Filter (Invoice or Customer Name or Member Name)\r\n        if (search) {\r\n            where.OR = [\r\n                { invoiceNo: { contains: search, mode: 'insensitive' } },\r\n                { customerName: { contains: search, mode: 'insensitive' } },\r\n                { member: { fullName: { contains: search, mode: 'insensitive' } } }\r\n            ];\r\n        }\r\n\r\n        const [total, orders] = await prisma.$transaction([\r\n            prisma.order.count({ where }),\r\n            prisma.order.findMany({\r\n                where,\r\n                take: limit,\r\n                skip: skip,\r\n                orderBy: { createdAt: 'desc' },\r\n                include: {\r\n                    items: true,\r\n                    member: {\r\n                        select: { fullName: true }\r\n                    }\r\n                }\r\n            })\r\n        ]);\r\n\r\n        // Map response to include resolved customer name\r\n        const mappedOrders = orders.map(order => ({\r\n            ...order,\r\n            // Priority: Member Name > Saved Customer Name > Guest\r\n            resolvedCustomerName: order.member?.fullName || (order as any).customerName || 'Guest'\r\n        }));\r\n\r\n        const totalPages = Math.ceil(total / limit);\r\n\r\n        return NextResponse.json({\r\n            success: true,\r\n            data: mappedOrders,\r\n            meta: {\r\n                total,\r\n                page,\r\n                limit,\r\n                totalPages,\r\n                hasNextPage: page < totalPages,\r\n                hasPrevPage: page > 1\r\n            }\r\n        });\r\n\r\n    } catch (error) {\r\n        console.error(\"Get Transactions Error:\", error);\r\n        return NextResponse.json({ error: \"Failed to fetch transactions\" }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}